<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Git Note | 夕航</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/docs/favicon.ico">
    <meta name="description" content="前端学习笔记">
    <meta name="author" content="夕航">
    <meta name="keywords" content="前端">
    
    <link rel="preload" href="/docs/assets/css/0.styles.52bb2005.css" as="style"><link rel="preload" href="/docs/assets/js/app.09d10d22.js" as="script"><link rel="preload" href="/docs/assets/js/5.2d095b72.js" as="script"><link rel="preload" href="/docs/assets/js/24.90483c50.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.e282c734.js"><link rel="prefetch" href="/docs/assets/js/11.d7e26b9e.js"><link rel="prefetch" href="/docs/assets/js/12.b841f052.js"><link rel="prefetch" href="/docs/assets/js/13.dc5aeac1.js"><link rel="prefetch" href="/docs/assets/js/14.60c39f06.js"><link rel="prefetch" href="/docs/assets/js/15.c4090a9d.js"><link rel="prefetch" href="/docs/assets/js/16.b82bdcb1.js"><link rel="prefetch" href="/docs/assets/js/17.99236714.js"><link rel="prefetch" href="/docs/assets/js/18.14c2d49c.js"><link rel="prefetch" href="/docs/assets/js/19.d02bbe47.js"><link rel="prefetch" href="/docs/assets/js/2.93ef2c17.js"><link rel="prefetch" href="/docs/assets/js/20.9e98372f.js"><link rel="prefetch" href="/docs/assets/js/21.42e19db8.js"><link rel="prefetch" href="/docs/assets/js/22.fef0060f.js"><link rel="prefetch" href="/docs/assets/js/23.81874084.js"><link rel="prefetch" href="/docs/assets/js/25.4cccfb01.js"><link rel="prefetch" href="/docs/assets/js/26.5c9d1ddf.js"><link rel="prefetch" href="/docs/assets/js/27.a9c08176.js"><link rel="prefetch" href="/docs/assets/js/28.63eab0b6.js"><link rel="prefetch" href="/docs/assets/js/29.beda502f.js"><link rel="prefetch" href="/docs/assets/js/3.c17983c0.js"><link rel="prefetch" href="/docs/assets/js/30.f395372d.js"><link rel="prefetch" href="/docs/assets/js/31.e809f027.js"><link rel="prefetch" href="/docs/assets/js/32.39b2d9fa.js"><link rel="prefetch" href="/docs/assets/js/33.ad475418.js"><link rel="prefetch" href="/docs/assets/js/34.b527ccb6.js"><link rel="prefetch" href="/docs/assets/js/35.4d3075ff.js"><link rel="prefetch" href="/docs/assets/js/36.e906c045.js"><link rel="prefetch" href="/docs/assets/js/37.cb809e5d.js"><link rel="prefetch" href="/docs/assets/js/38.b937dc87.js"><link rel="prefetch" href="/docs/assets/js/39.f9a8c19b.js"><link rel="prefetch" href="/docs/assets/js/4.01881906.js"><link rel="prefetch" href="/docs/assets/js/6.5dbe11a1.js"><link rel="prefetch" href="/docs/assets/js/7.e7b95553.js"><link rel="prefetch" href="/docs/assets/js/8.042a8261.js"><link rel="prefetch" href="/docs/assets/js/9.e326f00f.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.52bb2005.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><img src="/docs/logo.png" alt="夕航" class="logo"> <span class="site-name can-hide">夕航</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/docs/guide/" class="nav-link">
  前言
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/js/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/docs/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/docs/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/docs/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/docs/webpack/" class="nav-link">
  Webpack
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/docs/algorithm/" class="nav-link">
  数据结构与算法
</a></li></ul></div></div><div class="nav-item"><a href="/docs/interview/interview.html" class="nav-link">
  面试总结
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/docs/guide/" class="nav-link">
  前言
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/js/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/docs/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/docs/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/docs/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/docs/webpack/" class="nav-link">
  Webpack
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/docs/algorithm/" class="nav-link">
  数据结构与算法
</a></li></ul></div></div><div class="nav-item"><a href="/docs/interview/interview.html" class="nav-link">
  面试总结
</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="git-note"><a href="#git-note" class="header-anchor">#</a> Git Note</h3> <h2 id="git"><a href="#git" class="header-anchor">#</a> Git</h2> <h3 id="版本控制工具的功能"><a href="#版本控制工具的功能" class="header-anchor">#</a> 版本控制工具的功能</h3> <ul><li>协同修改</li> <li>数据备份</li> <li>版本管理
<ul><li>Git采取文件系统快照的方式</li></ul></li> <li>权限控制
<ul><li>对内进行权限控制</li> <li>对外对开发者进行审核--Git独有</li></ul></li> <li>历史记录
<ul><li>查看修改内容</li> <li>恢复到一个历史状态</li></ul></li> <li>分支管理
<ul><li>多条生产线同时推进</li></ul></li></ul> <h3 id="git的优势"><a href="#git的优势" class="header-anchor">#</a> Git的优势</h3> <ul><li>本地完成，不要联网</li> <li>完整性保证，利用hash</li> <li>尽可能添加数据而不是删除或修改数据，很少产生不可逆的操作，随时返回历史版本</li> <li>分支操作快捷流畅，创建和移动指针</li> <li>与Linux命令全面兼容</li></ul> <h3 id="git的本地结构"><a href="#git的本地结构" class="header-anchor">#</a> Git的本地结构</h3> <ul><li>工作区(working tree)：写代码</li> <li>暂存区(index file)：临时存储</li> <li>本地库：历史版本</li> <li>git add-&gt;暂存区 git commit-&gt;本地区</li></ul> <h3 id="git-和-代码托管中心"><a href="#git-和-代码托管中心" class="header-anchor">#</a> Git 和 代码托管中心</h3> <p>Github是代码托管中心，维护远程库</p> <ul><li>局域网
<ul><li>自己搭建</li></ul></li> <li>外网
<ul><li>码云</li> <li>Github</li></ul></li></ul> <h3 id="本地库和远程库"><a href="#本地库和远程库" class="header-anchor">#</a> 本地库和远程库</h3> <ul><li>团队内部协作
![image-20200301104518138](Git Note/image-20200301104518138.png)</li></ul> <h3 id="git基本原理"><a href="#git基本原理" class="header-anchor">#</a> Git基本原理</h3> <h4 id="hash"><a href="#hash" class="header-anchor">#</a> Hash</h4> <ul><li>特点
<ul><li>不管输入数据量多大，同一个hash算法，得到的结果长度都一样</li> <li>算法确定，输入确定，输出确定</li> <li>算法确定，输入变化，输出变化，通常很大（可用于校验文件）</li> <li>算法不可逆</li></ul></li> <li>Git 底层用的是SHA-1算法</li></ul> <h4 id="git保存版本的机制"><a href="#git保存版本的机制" class="header-anchor">#</a> Git保存版本的机制</h4> <ul><li>保存机制</li></ul> <p>![image-20201127114206213](/Users/zhouxihang/Desktop/知识总结/git/Git的基本使用/Git Note.assets/image-20201127114206213.png)</p> <ul><li><p>提交对象</p> <p>![image-20200301101718952](Git Note/image-20200301101718952.png)
每一个文件都有一个对应的blob对象指向，并且有一个独有的hash值，所有的blob对象由一个tree对象指向，这个tree对象又由一个提交对象commit指向。</p> <p>这个commit对象就是git log的commit的hash值</p> <p>![image-20201127114648109](/Users/zhouxihang/Desktop/知识总结/git/Git的基本使用/Git Note.assets/image-20201127114648109.png)</p></li> <li><p>提交对象及其父对象形成的链条</p></li></ul> <p>![image-20201127114726365](/Users/zhouxihang/Desktop/知识总结/git/Git的基本使用/Git Note.assets/image-20201127114726365.png)
Snapshot就是快照，所有的提交对象通过链表的方式表示时间关系</p> <h4 id="git分支管理机制"><a href="#git分支管理机制" class="header-anchor">#</a> Git分支管理机制</h4> <ul><li>分支的创建</li></ul> <p>![image-20200301102148044](Git Note/image-20200301102148044.png)</p> <ul><li>分支的切换</li></ul> <p>![image-20200301102446380](Git Note/image-20200301102446380.png)</p> <p>切换分支只是切换HEAD指针的指向所以很快</p> <ul><li>在分支上提交使得testing指针移动</li></ul> <p>![image-20201127115457114](/Users/zhouxihang/Desktop/知识总结/git/Git的基本使用/Git Note.assets/image-20201127115457114.png)</p> <p>在分支上提交只会移动testing指针</p> <ul><li>在master上也提交会造成分支</li></ul> <p>![image-20201127115727948](/Users/zhouxihang/Desktop/知识总结/git/Git的基本使用/Git Note.assets/image-20201127115727948.png)</p> <h2 id="git命令行"><a href="#git命令行" class="header-anchor">#</a> Git命令行</h2> <h3 id="_1-本地库操作"><a href="#_1-本地库操作" class="header-anchor">#</a> 1.本地库操作</h3> <h4 id="_1-1本地库初始化"><a href="#_1-1本地库初始化" class="header-anchor">#</a> 1.1本地库初始化</h4> <ul><li>命令：git init</li> <li>效果：生成一个 .git的本地库</li> <li>注意：.git目录中存放的是本地库相关的子目录和文件，不要乱整</li></ul> <h4 id="_1-2设置签名"><a href="#_1-2设置签名" class="header-anchor">#</a> 1.2设置签名</h4> <ul><li>形式：
用户名：tom
Email地址：随便写就行</li> <li>作用：区分不同开发人员身份</li> <li>辨析：和登录代码托管中心的不一样</li> <li>命令：
<ul><li>项目级别/仓库级别：仅在当前本地库范围内有效
<ul><li>git config user.name tom_pro</li> <li>git config user.email xxx@111.com</li> <li>信息保存位置： ./git/config</li></ul></li> <li>系统用户级别：登录当前操作系统的用户
<ul><li>git congig --global user.name tom_glb</li> <li>git congig --global user.email xxx@111.com</li> <li>信息保存位置： ~/.gitconfig （~为系统当前用户目录）</li></ul></li> <li>优先级：
<ul><li>就近原则：项目级别优先于系统用户级别</li> <li>如果只有系统用户级别的签名，就以系统用户级别的签名为准</li> <li>二者都没有不允许</li></ul></li></ul></li></ul> <h4 id="_1-3添加提交"><a href="#_1-3添加提交" class="header-anchor">#</a> 1.3添加提交</h4> <ul><li>git status  查看工作区，暂存区状态</li> <li>git add [file name]（若为. 表示所有文件）将工作区的提交到暂存区或开始追踪</li> <li>git commit -m &quot;commit_message&quot; [file name] （若为. 表示所有文件） 将暂存区提交到本地库
<ul><li>如果你想要将这一次的提交仍然采用上一次的commit log则可以使用 git commit --amend</li></ul></li></ul> <h4 id="_1-4历史记录"><a href="#_1-4历史记录" class="header-anchor">#</a> 1.4历史记录</h4> <ul><li>git log 查看历史记录
<ul><li>git log --pretty=oneline (以最简洁的方式显示日志 无提交信息)</li> <li>git log --oneline（比pretty更简洁，哈希值取一部分）</li> <li><strong>git reflog</strong>  (推荐)(HEAD@(指针移动的到这个历史记录的次数)，提交记录，齐全）</li> <li>多屏显示方式：如果记录很多就会默认是这种显示
<ul><li>空格向下翻页</li> <li>b向上翻页</li> <li>q退出</li></ul></li></ul></li></ul> <h4 id="_1-5前进后退"><a href="#_1-5前进后退" class="header-anchor">#</a> 1.5前进后退</h4> <ul><li><strong>基于索引值操作</strong>(推荐)
<ul><li>git reset --hard [索引值(只需要一部分索引值)]</li></ul></li> <li>使用^符号（只能往过去）
<ul><li>git reset --hard HEAD ^  n个符号回退n步</li> <li>git reset --hard HEAD^^ 退两步</li></ul></li> <li>使用~符号（只能往过去）
<ul><li>git reset --hard HEAD~[int 回退步数]</li></ul></li></ul> <h5 id="reset-命令的三个参数对比"><a href="#reset-命令的三个参数对比" class="header-anchor">#</a> reset 命令的三个参数对比</h5> <ul><li>--soft 参数
<ul><li>仅在本地库移动指针</li></ul></li> <li>--mixed 参数
<ul><li>本地库移动HEAD</li> <li>重置暂存区</li></ul></li> <li>--hard 参数
<ul><li>三个区域都改变</li></ul></li> <li>注意
<ul><li>--soft参数改变本地库，git会认为本地库和暂存区不一样，从而认为暂存区也改变了</li> <li>--mixed 改变本地库和暂存区，从而认为工作区变了</li></ul></li></ul> <h4 id="_1-6-删除文件在本地库找回"><a href="#_1-6-删除文件在本地库找回" class="header-anchor">#</a> 1.6 删除文件在本地库找回</h4> <ul><li>前提： 删除前的状态提交到了本地库</li> <li>同样回退到历史记录就可以了</li></ul> <h4 id="_1-7-比较文件差异"><a href="#_1-7-比较文件差异" class="header-anchor">#</a> 1.7 比较文件差异</h4> <ul><li>git diff[文件名]
<ul><li>将工作区中的文件和暂存区对应的文件进行比较</li></ul></li> <li>git diff[本地库中历史版本][文件名] eg: git diff[HEAD^][文件名]
<ul><li>工作区文件对比本地库文件</li> <li>不指定文件名就可以对比所有工作区文件</li></ul></li></ul> <h4 id="_1-8-分支管理"><a href="#_1-8-分支管理" class="header-anchor">#</a> 1.8 分支管理</h4> <ul><li><p>什么是分支</p> <ul><li>多条线推进多个任务</li></ul></li> <li><p>好处</p> <ul><li>并行开发，提高效率</li> <li>某分支开发失败不会对其他分支有影响，删除失败分支即可</li></ul></li> <li><p>git branch 查看所有分支</p> <ul><li>带*的分支是当前所在的分支，是HEAD指针指向的分支</li></ul> <p>![image-20201208171111329](Git Note.assets/image-20201208171111329.png)</p> <p>![image-20201208171125971](Git Note.assets/image-20201208171125971.png)</p></li> <li><p>git branch [分支名] 创建分支</p> <ul><li>这就是在当前所在的提交对象上创建一个指针</li></ul> <p>![image-20201208170955019](Git Note.assets/image-20201208170955019.png)</p> <ul><li>创建分支后在分支上进行开发会使得分之指针向前推进，如果分支同时推进会产生分叉</li></ul> <p>![image-20201208171356276](Git Note.assets/image-20201208171356276.png)</p></li> <li><p>git checkout [分支名] 切换分支</p> <ul><li>切换HEAD指针的指向</li></ul></li> <li><p>合并分支</p> <ul><li>第一：切换到要receiver分支</li> <li>第二：git merge [sender分支]</li> <li>通过merge合并分支后会在当前所在的分之多创建一个commit</li> <li>例子：合并前在master分支，merge到iss53分支</li></ul> <p>![image-20201208172337413](Git Note.assets/image-20201208172337413.png)</p> <p>![image-20201208172426757](Git Note.assets/image-20201208172426757.png)</p></li> <li><p>解决冲突</p> <ul><li><p>产生原因</p> <ul><li>再分出一个branch过后，两个 branch的同一个部分作出了不同的修改，若直接合并的话就会造成一个branch的修改丢失，所以需要进行手动修改</li></ul></li> <li><p>解决</p> <ul><li>编辑文件，删除特殊符号
<ul><li>vscode有支持的直接修改的选项</li></ul></li></ul> <p>![image-20201208172828631](Git Note.assets/image-20201208172828631.png)</p> <ul><li>把文件修改到满意的程度</li> <li>git add[文件名]</li> <li>生成commit
<ul><li>如果是merge的话直接git commit -m&quot;message&quot; ，会生成一个新的commit</li></ul></li> <li>如果是rebase的话应该使用git rebase --continue</li> <li>注意：在解决冲突的时候应该注意HEAD的指向，有可能HEAD此时指向的是fetch新生成的origin/&lt;&gt;分支</li></ul></li></ul></li> <li><p>git rebase [base分支]</p> <ul><li><p>以base分支为底重构提交历史，使得整个提交历史呈线形</p></li> <li><p>例子：</p> <p>以merge合并master和experiment分支，会多一个C5的commit对象，该对象其实比较冗余，并且历史纪录看起来并不清晰</p></li></ul> <p>![image-20201208174927519](Git Note.assets/image-20201208174927519.png)</p> <p>在experiment分支中执行git rebase master会得到以下提交历史：</p> <p>![image-20201208175147702](Git Note.assets/image-20201208175147702.png)</p> <p>再在master分支中执行git merge experiment就可以快进到以下：这样的合并更加的清晰</p> <p>![image-20201208175437659](Git Note.assets/image-20201208175437659.png)</p></li></ul> <h4 id="_1-9-git-stash"><a href="#_1-9-git-stash" class="header-anchor">#</a> 1.9 Git Stash</h4> <ul><li>git stash 或者是 git stash save ' ' 保存现在工作区的状态到一个存储状态的栈中</li> <li>git stash save'' 可以为这一次的状态命名</li> <li>git stash list
<ul><li>查看目前的状态栈的状态，有几个状态在栈中</li></ul></li> <li>git stash apply &lt;状态名&gt;
<ul><li>状态名不加的话默认用栈顶的状态来恢复</li></ul></li> <li>git stash pop
<ul><li>应用栈顶的状态并且把栈顶的状态删除</li></ul></li> <li>注意在应用stash到目前的工作区的时候有可能会引发冲突，需要进行冲突的解决</li></ul> <h4 id="_1-10-git-cherry-pick"><a href="#_1-10-git-cherry-pick" class="header-anchor">#</a> 1.10 git cherry-pick</h4> <p>对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。</p> <p>这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（<code>git merge</code>）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> cherry-pick <span class="token operator">&lt;</span>commitHash<span class="token operator">&gt;</span>
</code></pre></div><p>把其他分支上某一个commit的代码改动应用到当前分支上</p> <p><a href="https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html" target="_blank" rel="noopener noreferrer">阮一峰cherry-pick<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="远程库操作"><a href="#远程库操作" class="header-anchor">#</a> 远程库操作</h3> <h4 id="github"><a href="#github" class="header-anchor">#</a> Github</h4> <ul><li>远程库与本地库的交互逻辑</li></ul> <p>![image-20200301102905089](Git Note/image-20200301102905089.png)</p> <ul><li><p>创建远程库</p> <ul><li>在github上创建就好了</li></ul></li> <li><p>在本地创建远程库别名</p> <ul><li>查看本地所有别名
<ul><li>git remote -v</li></ul></li> <li>加入远程库别名
<ul><li>git remote add [别名] [远程库链接]</li></ul></li> <li>删除别名
<ul><li>git remote rm [别名]</li></ul></li></ul></li> <li><p>推送本地库</p> <ul><li>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</li> <li>如果省略远程分支名，则表示将本地分支推送与之存在&quot;追踪关系&quot;的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。
<ul><li>eg: git push origin master</li></ul></li> <li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</li></ul></li> <li><p>远程库克隆到本地库</p> <ul><li>git clone [远程库地址]</li> <li>三个效果
<ul><li>完整把远程库下载到本地</li> <li>创建origin远程地址别名</li> <li>初始化本地库</li></ul></li></ul></li> <li><p>邀请新成员</p> <ul><li>settings -&gt; collaboration-&gt;copy link-&gt;accept</li></ul></li> <li><p>拉取远程库的更新</p> <ul><li><p>fetch</p> <ul><li>git fetch [远程库地址别名] [远程分支名]</li> <li>只把远程内容下载到本地，不做更改</li> <li>要看下载内容要切换到远程库的fetch的分支上
<ul><li>git checkout [远程库地址别名/远程分支名]</li> <li>当你从远程库fetch东西了过后就会自动创建一个[远程库地址别名/远程分支名]的分支</li></ul></li></ul></li> <li><p>merge</p> <ul><li>git merge [远程库地址别名/远程分支名]</li> <li>merge的作用就是把写的分支合并到当前分支，所以就把被创建的[远程库地址别名/远程分支名]分支合并到当前分支</li></ul></li> <li><p>pull = fetch + merge</p> <ul><li><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p></li> <li><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p></li> <li><p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p></li> <li><p>如果合并需要采用rebase模式，可以使用<code>--rebase</code>选项。</p> <ul><li><div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token function">git</span> pull --rebase <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">&gt;</span>
</code></pre></div></li> <li><p>git pull --rebase其实作用等于先git fetch再git rebase</p></li> <li><p>为什么使用--rebase?</p></li> <li><p>![5](Git Note.assets/202205-20161112141356827-143146414.png)</p> <ul><li>正常情况在apiwrapper分支上pull下更新合并会产生F这个默认的commit使得log十分冗杂</li></ul></li> <li><p>![6](Git Note.assets/202205-20161112141357467-370907848.png)</p> <ul><li>但是这种--rebase的方式就只会保持一条单一的commit记录</li></ul></li></ul></li></ul></li></ul></li> <li><p>协同开发时的冲突和解决</p> <ul><li>跟多分支的时候发生的冲突类似，若不是基于github远程库最新版所做的修改，不能推送，必须要先拉取下来在推送</li> <li>要先拉取下来最新的版本，这个时候会提示冲突，然后再去除特殊符号，改成想要的样子，再修改到本地库并推送。</li> <li>注意： 参考解决本地多分支冲突，commit不加文件名</li></ul></li> <li><p>跨团队协作操作</p> <ul><li><p>fork</p> <ul><li>以团队外参与人的身份点fork</li></ul> <p>![image-20200301114330949](Git Note/image-20200301114330949.png)</p></li> <li><p>clone</p> <ul><li>clone下因为fork新建远程库的内容到本地</li></ul></li> <li><p>本地修改并推送到fork远程库</p></li> <li><p>Pull request</p> <ul><li>new pull request -&gt; create pull request-&gt;填写消息</li> <li>接受人再点commit-changer看修改操作，若无问题则merge pull request</li> <li>接受人再把修改拉到本地</li></ul></li></ul></li></ul> <h3 id="git-hooks"><a href="#git-hooks" class="header-anchor">#</a> Git hooks</h3> <ul><li><p>git hooks是一些自定义的脚本，用于控制git工作的流程，分为<strong>客户端</strong>钩子和<strong>服务端</strong>钩子。</p></li> <li><p>客户端钩子包括：<code>pre-commit</code>、<code>prepare-commit-msg</code>、<code>commit-msg</code>、<code>post-commit</code>等，主要用于控制客户端git的提交工作流。服务端钩子：<code>pre-receive</code>、<code>post-receive</code>、<code>update</code>，主要在服务端接收提交对象时、推送到服务器之前调用。</p></li> <li><p>git hooks位置位于每个git项目下的隐藏文件夹.git中的hooks文件夹里，进去后会看到一些hooks的官方示例，他们都是以.sample结尾的文件名。<strong>注意这些以.sample结尾的示例脚本是不会执行的，只有重命名后才会生效</strong></p></li></ul> <h4 id="pre-commit的例子"><a href="#pre-commit的例子" class="header-anchor">#</a> pre-commit的例子</h4> <ul><li><code>pre-commit</code>是客户端hooks之一，也是接下来要介绍的钩子。<code>pre-commit</code>在<code>git add</code>提交之后，然后执行<code>git commit</code>时执行，脚本执行没报错就继续提交，反之就驳回提交的操作。</li> <li>这个钩子中可以实现：对将要提交的代码进行检查、优化代码格式、或者对提交的图片进行压缩等等任务。下面是用shell编写的具体代码：</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token assign-left variable">STAGE_FILES</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">git</span> <span class="token function">diff</span> --cached --name-only --diff-filter<span class="token operator">=</span>ACM -- <span class="token string">'*.vue'</span> <span class="token string">'*.js'</span><span class="token variable">)</span></span>
<span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token variable">${<span class="token operator">#</span>STAGE_FILES}</span> -gt <span class="token number">0</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'开始eslint检查'</span>

    <span class="token function">which</span> eslint <span class="token operator">&amp;&gt;</span> /dev/null
    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">$?</span>&quot;</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">'没安装eslint'</span>
        <span class="token builtin class-name">exit</span> <span class="token number">1</span>
    <span class="token keyword">fi</span>

    <span class="token assign-left variable">PASS</span><span class="token operator">=</span>true

    <span class="token keyword">for</span> <span class="token for-or-select variable">FILE</span> <span class="token keyword">in</span> <span class="token variable">$STAGE_FILES</span>
    <span class="token keyword">do</span>
        eslint <span class="token variable">$FILE</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">$?</span>&quot;</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
      <span class="token assign-left variable">PASS</span><span class="token operator">=</span>false
    <span class="token keyword">fi</span>
  <span class="token keyword">done</span>

  <span class="token keyword">if</span> <span class="token operator">!</span> <span class="token variable">$PASS</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
      <span class="token builtin class-name">echo</span> <span class="token string">&quot;eslint检查没通过！&quot;</span>
      <span class="token builtin class-name">exit</span> <span class="token number">1</span>
  <span class="token keyword">else</span>
      <span class="token builtin class-name">echo</span> <span class="token string">&quot;eslint检查完毕&quot;</span>
  <span class="token keyword">fi</span>

<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'没有js文件需要检查'</span>
<span class="token keyword">fi</span>

<span class="token builtin class-name">exit</span> <span class="token number">0</span>
</code></pre></div><p>稍微解释下：首先用<code>git diff</code>获取到提交到暂存区的文件，我这里添加了过滤即只获取.vue和.js文件。</p> <p>然后判断eslint是否已安装，接着再对获取到的文件依次检查，当某个文件检查不通过时不会中断进程，会继续遍历所有文件，这样最后在控制台可以显示出所有检查不通过的文件信息</p> <p>exit即表示退出当前脚本进程、后面接上状态码，0表示正常，会继续执行<code>git commit</code>的操作，其他情况表示出错，不会继续commit。</p> <p>将上面的代码保存为<code>pre-commit</code>，然后存放在.git/hooks中，然后每次执行<code>git commit</code>时就会使用eslint进行代码检查了。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.09d10d22.js" defer></script><script src="/docs/assets/js/5.2d095b72.js" defer></script><script src="/docs/assets/js/24.90483c50.js" defer></script>
  </body>
</html>
